<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagrama de Sankey de Energía</title>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #sankey-diagram {
            width: 95vw;
            height: 80vh;
        }
    </style>
</head>

<body>
    <h1>Diagrama de Sankey de Energía en México</h1>
    <div>
        <label for="year-selector">Selecciona un año:</label>
        <select id="year-selector"></select>
    </div>
    <div id="sankey-diagram"></div>

    <script>
        const yearSelector = document.getElementById('year-selector');
        const sankeyDiv = document.getElementById('sankey-diagram');
        let energyData = [];
        let allNodes = [];

        // Cargar los datos desde el archivo JSON
        fetch('./datos_energia_completo.json')
            .then(response => response.json())
            .then(data => {
                energyData = data.Datos;
                populateYearSelector();
                // Inicializar el gráfico con el primer año disponible
                updateSankey(yearSelector.value);
            })
            .catch(error => console.error('Error al cargar el JSON:', error));

        // Poblar el selector de años dinámicamente
        function populateYearSelector() {
            const years = new Set();
            energyData.forEach(padre => {
                padre['Nodos Hijo'].forEach(hijo => {
                    Object.keys(hijo).forEach(key => {
                        if (!isNaN(key) && key.length === 4 && key !== '2025') {
                            years.add(key);
                        }
                    });
                });
            });

            const sortedYears = Array.from(years).sort((a, b) => b - a);

            sortedYears.forEach(year => {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                yearSelector.appendChild(option);
            });

            // Añadir el evento para actualizar el gráfico cuando cambia el año
            yearSelector.addEventListener('change', (event) => {
                updateSankey(event.target.value);
            });
        }

        // Función para actualizar el diagrama de Sankey (Etapa 1.7: Añadir Salidas Completas)
        function updateSankey(year) {
            console.log(`Actualizando gráfico para el año: ${year}`);

            Plotly.purge(sankeyDiv);

            const produccionData = energyData.find(p => p['Nodo Padre'] === 'Producción');
            const importacionData = energyData.find(p => p['Nodo Padre'] === 'Importación');
            const variacionData = energyData.find(p => p['Nodo Padre'] === 'Variación de Inventarios');
            const exportacionData = energyData.find(p => p['Nodo Padre'] === 'Exportación');
            const ofertaInternaBrutaData = energyData.find(p => p['Nodo Padre'] === 'Oferta Interna Bruta');
            const energiaNoAprovechadaData = energyData.find(p => p['Nodo Padre'] === 'Energía No Aprovechada');
            const consumoPropioData = energyData.find(p => p['Nodo Padre'] === 'Consumo Propio del Sector');
            const coquizadorasHornosData = energyData.find(p => p['Nodo Padre'] === 'Coquizadoras y Hornos');
            const refineriasDespuntadorasData = energyData.find(p => p['Nodo Padre'] === 'Refinerías y Despuntadoras');
            const plantasGasFraccionadorasData = energyData.find(p => p['Nodo Padre'] === 'Plantas de Gas y Fraccionadoras');
            const centralesElectricasData = energyData.find(p => p['Nodo Padre'] === 'Centrales Eléctricas');
            const carboelectricaData = energyData.find(p => p['Nodo Padre'] === 'Carboeléctrica');
            const termicaConvencionalData = energyData.find(p => p['Nodo Padre'] === 'Térmica Convencional');
            const combustionInternaData = energyData.find(p => p['Nodo Padre'] === 'Combustión Interna');
            const turbogasData = energyData.find(p => p['Nodo Padre'] === 'Turbogás');
            const cicloCombinadoData = energyData.find(p => p['Nodo Padre'] === 'Ciclo Combinado');
            const nucleoelectricaData = energyData.find(p => p['Nodo Padre'] === 'Nucleoeléctrica');
            const cogeneracionData = energyData.find(p => p['Nodo Padre'] === 'Cogeneración');
            const geotermicaData = energyData.find(p => p['Nodo Padre'] === 'Geotérmica');
            const eolicaData = energyData.find(p => p['Nodo Padre'] === 'Eólica');
            const solarFotovoltaicaData = energyData.find(p => p['Nodo Padre'] === 'Solar Fotovoltaica');

            if (!produccionData || !importacionData || !variacionData || !ofertaInternaBrutaData || !exportacionData || !energiaNoAprovechadaData || !consumoPropioData) {
                console.error('Faltan datos de nodos padres');
                Plotly.react(sankeyDiv, [], { title: `Datos incompletos para ${year}` });
                return;
            }

            const labels = [];
            const nodeColors = [];
            const nodeMap = new Map();
            const primaryEnergyTotals = new Map();

            const source = [];
            const target = [];
            const value = [];
            const linkColors = [];
            const linkCustomdata = [];

            function addNode(name, color) {
                // Unificar el nodo 'Carbón mineral' para todos los flujos
                // Asegurar que el color sea string
                const safeColor = typeof color === 'string' ? color : '#888';
                if (name === 'Carbón mineral') {
                    if (!nodeMap.has(name)) {
                        nodeMap.set(name, labels.length);
                        labels.push(name);
                        nodeColors.push(safeColor);
                    }
                    return nodeMap.get(name);
                }
                // Para los demás nodos, comportamiento normal
                if (!nodeMap.has(name)) {
                    nodeMap.set(name, labels.length);
                    labels.push(name);
                    nodeColors.push(safeColor);
                }
                return nodeMap.get(name);
            }

            // --- 1. Definir Nodos Principales ---
            const importacionIndex = addNode(String('Importación de energéticos primarios'), importacionData.color);
            const variacionIndex = addNode(String('Variación de inventarios de Energéticos primarios'), variacionData.color);
            const produccionIndex = addNode(String('Producción'), produccionData.color);
            const ofertaTotalData = energyData.find(p => p['Nodo Padre'] === 'Oferta Total');
            const primariosHubIndex = addNode(String('Oferta Total (Hub)'), ofertaTotalData.color);
            const ofertaInternaBrutaIndex = addNode(String('Oferta Interna Bruta'), ofertaInternaBrutaData.color);
            const exportacionIndex = addNode(String('Exportación'), exportacionData.color);
            const energiaNoAprovechadaIndex = addNode(String('Energía No Aprovechada'), energiaNoAprovechadaData.color);
            const consumoPropioIndex = addNode(String('Consumo Propio del Sector'), consumoPropioData.color);
            const coquizadorasHornosIndex = addNode(String('Coquizadoras y Hornos'), coquizadorasHornosData.color);
            const refineriasDespuntadorasIndex = addNode(String('Refinerías y Despuntadoras'), refineriasDespuntadorasData.color);
            const plantasGasFraccionadorasIndex = addNode(String('Plantas de Gas y Fraccionadoras'), plantasGasFraccionadorasData.color);
            const centralesElectricasIndex = addNode(String('Centrales Eléctricas'), centralesElectricasData.color);
            const carboelectricaIndex = addNode(String('Carboeléctrica'), carboelectricaData.color);
            const termicaConvencionalIndex = addNode(String('Térmica Convencional'), termicaConvencionalData.color);
            const combustionInternaIndex = addNode(String('Combustión Interna'), combustionInternaData.color);
            const turbogasIndex = addNode(String('Turbogás'), turbogasData.color);
            const cicloCombinadoIndex = addNode(String('Ciclo Combinado'), cicloCombinadoData.color);
            const nucleoelectricaIndex = addNode(String('Nucleoeléctrica'), nucleoelectricaData.color);
            const cogeneracionIndex = addNode(String('Cogeneración'), cogeneracionData.color);
            const geotermicaIndex = addNode(String('Geotérmica'), geotermicaData.color);
            const eolicaIndex = addNode(String('Eólica'), eolicaData.color);
            const solarFotovoltaicaIndex = addNode(String('Solar Fotovoltaica'), solarFotovoltaicaData.color);
            // --- 2. Procesar Flujos de Entrada (Fuentes -> Tipos de Energía) ---
            const linkSigns = [];
            const processParentNode = (nodeData, parentIndex, allowNegatives = false) => {
                // Ordenar nodos hijo por id_hijo de menor a mayor
                const hijosOrdenados = [...nodeData['Nodos Hijo']].sort((a, b) => {
                    // Si no existe id_hijo, lo ponemos al final
                    if (a.id_hijo === undefined) return 1;
                    if (b.id_hijo === undefined) return -1;
                    return a.id_hijo - b.id_hijo;
                });
                hijosOrdenados.forEach(child => {
                    const flowValue = child[year];
                    if (child.tipo === 'Energía Primaria' && flowValue !== undefined && flowValue !== 0) {
                        const childName = child['Nodo Hijo'];
                        const childColor = child.color;
                        const childIndex = addNode(childName, childColor);
                        source.push(parentIndex);
                        target.push(childIndex);
                        value.push(Math.log10(Math.abs(flowValue) + 1));
                        linkColors.push(
                            typeof childColor === 'string'
                                ? childColor
                                : '#888'
                        );
                        linkCustomdata.push(`${childName}: ${Math.abs(flowValue).toLocaleString()} PJ`);
                        linkSigns.push(flowValue > 0 ? '+' : '-');
                        // Sumar o restar según el signo
                        if (allowNegatives && flowValue < 0) {
                            primaryEnergyTotals.set(childName, (primaryEnergyTotals.get(childName) || 0) - Math.abs(flowValue));
                        } else {
                            primaryEnergyTotals.set(childName, (primaryEnergyTotals.get(childName) || 0) + flowValue);
                        }
                    }
                });
            };
            processParentNode(importacionData, importacionIndex);
            processParentNode(variacionData, variacionIndex, true);
            processParentNode(produccionData, produccionIndex);

            // --- 3. Procesar Flujos (Tipos de Energía -> Hub "Energéticos Primarios") ---
            for (const [energyName, totalValue] of primaryEnergyTotals.entries()) {
                const energyIndex = nodeMap.get(energyName);
                const energyColor = nodeColors[energyIndex];
                source.push(energyIndex);
                target.push(primariosHubIndex);
                value.push(Math.log10(totalValue + 1));
                linkColors.push(
                    typeof energyColor === 'string'
                        ? energyColor
                        : '#888'
                );
                linkCustomdata.push(`${energyName}: ${Math.abs(totalValue).toLocaleString()} PJ`);
            }

            // --- 4. Procesar Flujos (Oferta Total -> Oferta Interna Bruta) ---
            ofertaInternaBrutaData['Nodos Hijo'].forEach(child => {
                const flowValue = child[year];
                if (child.tipo === 'Energía Primaria' && flowValue !== undefined && flowValue !== 0) {
                    const childName = child['Nodo Hijo'];
                    const childColor = child.color;

                    source.push(primariosHubIndex);
                    target.push(ofertaInternaBrutaIndex);
                    value.push(Math.log10(Math.abs(flowValue) + 1));
                    linkColors.push(
                        typeof childColor === 'string'
                            ? childColor
                            : '#888'
                    );
                    linkCustomdata.push(`${childName}: ${Math.abs(flowValue).toLocaleString()} PJ`);
                }
            });

            // --- 5. Procesar Flujos de Salida (Oferta Total -> Exportación) ---
            exportacionData['Nodos Hijo'].forEach(child => {
                const flowValue = child[year];
                if (child.tipo === 'Energía Primaria' && flowValue !== undefined && flowValue !== 0) {
                    const childName = child['Nodo Hijo'];
                    const childColor = child.color;

                    source.push(primariosHubIndex);
                    target.push(exportacionIndex);
                    value.push(Math.log10(Math.abs(flowValue) + 1));
                    linkColors.push(
                        typeof childColor === 'string'
                            ? childColor
                            : '#888'
                    );
                    linkCustomdata.push(`${childName}: ${Math.abs(flowValue).toLocaleString()} PJ`);
                }
            });

            // --- 6. Procesar Flujos de Salida (Oferta Total -> Energía No Aprovechada) ---
            energiaNoAprovechadaData['Nodos Hijo'].forEach(child => {
                const flowValue = child[year];
                if (child.tipo === 'Energía Primaria' && flowValue !== undefined && flowValue !== 0) {
                    const childName = child['Nodo Hijo'];
                    const childColor = child.color;

                    source.push(primariosHubIndex);
                    target.push(energiaNoAprovechadaIndex);
                    value.push(Math.log10(Math.abs(flowValue) + 1));
                    linkColors.push(
                        typeof childColor === 'string'
                            ? childColor
                            : '#888'
                    );
                    linkCustomdata.push(`${childName}: ${Math.abs(flowValue).toLocaleString()} PJ`);
                }
            });

            // --- 7. Procesar Flujos (Oferta Interna Bruta -> Coquizadoras y Hornos) ---
            coquizadorasHornosData['Nodos Hijo'].forEach(child => {
                const flowValue = child[year];
                // Asumimos que Carbón mineral es el input principal de OIB a Coquizadoras y Hornos
                if (child['Nodo Hijo'] === 'Carbón mineral' && flowValue !== undefined && flowValue !== 0) {
                    const childColor = child.color;
                    source.push(ofertaInternaBrutaIndex);
                    target.push(coquizadorasHornosIndex);
                    value.push(Math.log10(Math.abs(flowValue) + 1));
                    linkColors.push(
                        typeof childColor === 'string'
                            ? childColor
                            : '#888'
                    );
                    linkCustomdata.push(`${child['Nodo Hijo']}: ${Math.abs(flowValue).toLocaleString()} PJ`);
                }
            });

            // --- 7. Procesar Flujos (Oferta Interna Bruta -> Refinerías y Despuntadoras) ---
            refineriasDespuntadorasData['Nodos Hijo'].forEach(child => {
                const flowValue = child[year];
                // Asumimos que Petróleo crudo es el input principal de OIB a Refinerías y Despuntadoras
                if (child['Nodo Hijo'] === 'Petróleo crudo' && flowValue !== undefined && flowValue !== 0) {
                    const childColor = child.color;
                    source.push(ofertaInternaBrutaIndex);
                    target.push(refineriasDespuntadorasIndex);
                    value.push(Math.log10(Math.abs(flowValue) + 1));
                    linkColors.push(
                        typeof childColor === 'string'
                            ? childColor
                            : '#888'
                    );
                    linkCustomdata.push(`${child['Nodo Hijo']}: ${Math.abs(flowValue).toLocaleString()} PJ`);
                }
            });

            // --- 8. Procesar Flujos (Oferta Interna Bruta -> Plantas de Gas y Fraccionadoras) ---
            plantasGasFraccionadorasData['Nodos Hijo'].forEach(child => {
                const flowValue = child[year];
                // Asumimos que Gas natural y Condensados son los inputs principales de OIB a Plantas de Gas y Fraccionadoras
                if ((child['Nodo Hijo'] === 'Gas natural' || child['Nodo Hijo'] === 'Condensados') && flowValue !== undefined && flowValue !== 0) {
                    const childColor = child.color;
                    source.push(ofertaInternaBrutaIndex);
                    target.push(plantasGasFraccionadorasIndex);
                    value.push(Math.log10(Math.abs(flowValue) + 1));
                    linkColors.push(
                        typeof childColor === 'string'
                            ? childColor
                            : '#888'
                    );
                    linkCustomdata.push(`${child['Nodo Hijo']}: ${Math.abs(flowValue).toLocaleString()} PJ`);
                }
            });

            // --- 9. Procesar Flujos (Fuentes de Energía -> Tecnologías de Generación) ---
            const fuelToTechMap = {
                'Carbón mineral': [carboelectricaIndex],
                'Coque de carbón': [carboelectricaIndex],
                'Combustóleo': [termicaConvencionalIndex],
                'Coque de petróleo': [termicaConvencionalIndex],
                'Diesel': [combustionInternaIndex],
                'Gas natural': [cicloCombinadoIndex],
                'Gas natural seco': [cicloCombinadoIndex, termicaConvencionalIndex], // Ahora puede ir a Ciclo Combinado y Térmica Convencional
                'Energía Nuclear': [nucleoelectricaIndex],
                'Geoenergía': [geotermicaIndex],
                'Energía eólica': [eolicaIndex],
                'Energía solar': [solarFotovoltaicaIndex],
                'Bagazo de caña': [termicaConvencionalIndex],
                'Biogás': [termicaConvencionalIndex],
                'Leña': [termicaConvencionalIndex],
                // Nota: Turbogás y Térmica Convencional también pueden usar Gas Natural Seco,
                // pero los datos no especifican la distribución.
            };

            if (centralesElectricasData && centralesElectricasData['Nodos Hijo']) {
                centralesElectricasData['Nodos Hijo'].forEach(fuel => {
                    const flowValue = fuel[year];
                    if (flowValue !== undefined && flowValue !== 0) {
                        const fuelName = fuel['Nodo Hijo'];
                        const fuelColor = fuel.color;
                        const targetIndices = fuelToTechMap[fuelName];

                        if (targetIndices && targetIndices.length > 0) {
                            targetIndices.forEach(targetIndex => {
                                let sourceIndex;
                                if (fuel.tipo === 'Energía Primaria') {
                                    sourceIndex = ofertaInternaBrutaIndex;
                                } else { // Energía Secundaria
                                    if (fuelName === 'Coque de carbón') {
                                        sourceIndex = coquizadorasHornosIndex;
                                    } else if (fuelName === 'Gas natural seco') {
                                        // Simplificación: Asumimos que el gas seco para generación viene de plantas de gas
                                        // si el dato existe, si no, de refinerías.
                                        sourceIndex = plantasGasFraccionadorasData ? plantasGasFraccionadorasIndex : refineriasDespuntadorasIndex;
                                    } else {
                                        sourceIndex = refineriasDespuntadorasIndex;
                                    }
                                }

                                if (sourceIndex !== undefined) {
                                    source.push(sourceIndex);
                                    target.push(targetIndex);
                                    value.push(Math.log10(Math.abs(flowValue) + 1));
                                    linkColors.push(typeof fuelColor === 'string' ? fuelColor : '#888');
                                    linkCustomdata.push(`${fuelName}: ${Math.abs(flowValue).toLocaleString()} PJ`);
                                }
                            });
                        }
                    }
                });
            }

            // --- 10. Procesar Flujos (Tecnologías de Generación -> Centrales Eléctricas) ---
            const generationNodes = [
                { data: carboelectricaData, index: carboelectricaIndex, name: 'Carboeléctrica' },
                { data: termicaConvencionalData, index: termicaConvencionalIndex, name: 'Térmica Convencional' },
                { data: combustionInternaData, index: combustionInternaIndex, name: 'Combustión Interna' },
                { data: turbogasData, index: turbogasIndex, name: 'Turbogás' },
                { data: cicloCombinadoData, index: cicloCombinadoIndex, name: 'Ciclo Combinado' },
                { data: nucleoelectricaData, index: nucleoelectricaIndex, name: 'Nucleoeléctrica' },
                { data: cogeneracionData, index: cogeneracionIndex, name: 'Cogeneración' },
                { data: geotermicaData, index: geotermicaIndex, name: 'Geotérmica' },
                { data: eolicaData, index: eolicaIndex, name: 'Eólica' },
                { data: solarFotovoltaicaData, index: solarFotovoltaicaIndex, name: 'Solar Fotovoltaica' }
            ];

            generationNodes.forEach(genNode => {
                if (genNode.data && genNode.data['Nodos Hijo']) {
                    genNode.data['Nodos Hijo'].forEach(child => {
                        if (child['Nodo Hijo'] === 'Energía eléctrica') {
                            const flowValue = child[year];
                            if (flowValue !== undefined && flowValue !== 0) {
                                source.push(genNode.index);
                                target.push(centralesElectricasIndex);
                                value.push(Math.log10(Math.abs(flowValue) + 1));
                                linkColors.push(typeof child.color === 'string' ? child.color : '#888');
                                linkCustomdata.push(`Producción de ${genNode.name}: ${Math.abs(flowValue).toLocaleString()} PJ`);
                            }
                        }
                    });
                }
            });

            // --- 13. Procesar Flujos de Salida (Oferta Total -> Consumo Propio del Sector) ---
            consumoPropioData['Nodos Hijo'].forEach(child => {
                const flowValue = child[year];
                if (child.tipo === 'Energía Primaria' && flowValue !== undefined && flowValue !== 0) {
                    const childName = child['Nodo Hijo'];
                    const childColor = child.color;
                    // const energyIndex = nodeMap.get(childName); // Obtener el índice del nodo de energético primario

                    source.push(primariosHubIndex);
                    target.push(consumoPropioIndex);
                    value.push(Math.log10(Math.abs(flowValue) + 1));
                    linkColors.push(
                        typeof childColor === 'string'
                            ? childColor
                            : '#888'
                    );
                    linkCustomdata.push(`${childName}: ${Math.abs(flowValue).toLocaleString()} PJ`);
                }
            });

            // --- 6. Forzar Posiciones de los Nodos ---
            const nodeX = new Array(labels.length);
            const nodeY = new Array(labels.length);
            const ySourcePositions = {
                'Importación de energéticos primarios': 0.05,
                'Variación de inventarios de Energéticos primarios': 0.5,
                'Producción': 0.95
            };

            // Calcular sumas para el nodo de variación de inventarios
            let variacionPositiva = 0;
            let variacionNegativa = 0;
            variacionData['Nodos Hijo'].forEach(child => {
                const flowValue = child[year];
                if (child.tipo === 'Energía Primaria' && flowValue !== undefined && flowValue !== 0) {
                    if (flowValue > 0) variacionPositiva += flowValue;
                    if (flowValue < 0) variacionNegativa += flowValue;
                }
            });
            const variacionTotalAbs = Math.abs(variacionPositiva) + Math.abs(variacionNegativa);

            labels.forEach((label, i) => {
                // Asignar posición horizontal y vertical para los nodos de entrada y salida
                if (label === 'Importación de energéticos primarios') {
                    nodeX[i] = 0.01;
                    nodeY[i] = 0.1; // Ajustado para más espacio
                } else if (label === 'Variación de inventarios de Energéticos primarios') {
                    nodeX[i] = 0.01;
                    nodeY[i] = 0.3; // Ajustado para más espacio
                } else if (label === 'Producción') {
                    nodeX[i] = 0.01;
                    nodeY[i] = 0.7; // Ajustado para más espacio
                } else if (label === 'Oferta Total (Hub)') {
                    nodeX[i] = 0.3; // Posición horizontal del hub
                    nodeY[i] = 0.4; // Ajustado para alinear con los flujos de entrada
                } else if (label === 'Oferta Interna Bruta') {
                    nodeX[i] = 0.4; // Más cerca de Oferta Total (Hub)
                    nodeY[i] = 0.1; // Arriba de Exportación
                } else if (label === 'Refinerías y Despuntadoras') {
                    nodeX[i] = 0.5; // A la derecha de Oferta Interna Bruta
                    nodeY[i] = 0.2; // Posición vertical
                } else if (label === 'Plantas de Gas y Fraccionadoras') {
                    nodeX[i] = 0.5; // A la derecha de Oferta Interna Bruta
                    nodeY[i] = 0.3; // Posición vertical
                } else if (label === 'Coquizadoras y Hornos') {
                    nodeX[i] = 0.5; // A la derecha de Oferta Interna Bruta
                    nodeY[i] = 0.4; // Posición vertical
                } else if (label === 'Carboeléctrica') {
                    nodeX[i] = 0.6;
                    nodeY[i] = 0.4;
                } else if (label === 'Térmica Convencional') {
                    nodeX[i] = 0.6;
                    nodeY[i] = 0.46;
                } else if (label === 'Combustión Interna') {
                    nodeX[i] = 0.6;
                    nodeY[i] = 0.52;
                } else if (label === 'Turbogás') {
                    nodeX[i] = 0.6;
                    nodeY[i] = 0.58;
                } else if (label === 'Ciclo Combinado') {
                    nodeX[i] = 0.6;
                    nodeY[i] = 0.64;
                } else if (label === 'Nucleoeléctrica') {
                    nodeX[i] = 0.6;
                    nodeY[i] = 0.70;
                } else if (label === 'Cogeneración') {
                    nodeX[i] = 0.6;
                    nodeY[i] = 0.76;
                } else if (label === 'Geotérmica') {
                    nodeX[i] = 0.6;
                    nodeY[i] = 0.82;
                } else if (label === 'Eólica') {
                    nodeX[i] = 0.6;
                    nodeY[i] = 0.88;
                } else if (label === 'Solar Fotovoltaica') {
                    nodeX[i] = 0.6;
                    nodeY[i] = 0.94;
                } else if (label === 'Centrales Eléctricas') {
                    nodeX[i] = 0.8; // Punto de convergencia final
                    nodeY[i] = 0.7; // Centrado verticalmente con los nuevos nodos de generación
                } else if (label === 'Exportación') {
                    nodeX[i] = 0.4; // Posición horizontal después del hub
                    nodeY[i] = 0.7; // Posición vertical
                } else if (label === 'Consumo Propio del Sector') {
                    nodeX[i] = 0.4; // Posición horizontal después del hub
                    nodeY[i] = 0.8; // Posición vertical
                } else if (label === 'Energía No Aprovechada') {
                    nodeX[i] = 0.4; // Posición horizontal después del hub
                    nodeY[i] = 0.9; // Posición vertical
                }
            });

            // Custom hovertemplate for links with sign
            const customLinkHover = value.map((v, i) => {
                return `${labels[source[i]]} → ${labels[target[i]]}<br>Signo: ${linkSigns[i] || '+'} ${v.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} PJ<extra></extra>`;
            });

            // Usar un solo string para hovertemplate de nodos
            const customNodeHover =
                '%{label}<br>Total: %{value:,.2f} PJ' +
                '<br>%{customdata}' +
                '<extra></extra>';

            // Preparar customdata para cada nodo
            const customNodeData = labels.map(label => {
                if (label === 'Variación de inventarios de Energéticos primarios') {
                    return `+ Suma positiva: ${variacionPositiva.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} PJ<br>- Suma negativa: ${variacionNegativa.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} PJ<br>Total absoluto: ${variacionTotalAbs.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} PJ`;
                }
                return '';
            });

            const data = {
                type: "sankey",
                orientation: "h",
                node: {
                    pad: 15,
                    thickness: 20,
                    line: { color: "black", width: 0.5 },
                    label: labels,
                    color: nodeColors,
                    hovertemplate: customNodeHover,
                    customdata: customNodeData,
                    x: nodeX,
                    y: nodeY,
                    font: { size: 6 } // Reducir el tamaño de la fuente aún más
                },
                link: { source: source, target: target, value: value, color: linkColors, customdata: linkCustomdata, hovertemplate: '%{customdata}<extra></extra>' }
            };

            const layout = { title: `Flujo de Fuentes a Oferta Total y Salidas - ${year} (Valores en PJ)`, font: { size: 12 } };
            const config = { displaylogo: false, toImageButtonOptions: { format: 'png', filename: `sankey_energia_primaria_${year}`, setBackground: 'transparent' } };

            Plotly.newPlot(sankeyDiv, [data], layout, config);
        }
    </script>
</body>

</html>