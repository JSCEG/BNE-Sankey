<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagrama de Sankey de Energía</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #sankey-diagram {
            width: 95vw;
            height: 80vh;
        }
    </style>
</head>

<body>
    <h1>Diagrama de Sankey de Energía en México</h1>
    <div>
        <label for="year-selector">Selecciona un año:</label>
        <select id="year-selector"></select>
    </div>
    <div id="sankey-diagram"></div>

    <script>
        const yearSelector = document.getElementById('year-selector');
        const sankeyDiv = document.getElementById('sankey-diagram');
        let energyData = [];
        let allNodes = [];

        // Cargar los datos desde el archivo JSON
        fetch('./datos_energia_completo.json')
            .then(response => response.json())
            .then(data => {
                energyData = data.Datos;
                populateYearSelector();
                // Inicializar el gráfico con el primer año disponible
                updateSankey(yearSelector.value);
            })
            .catch(error => console.error('Error al cargar el JSON:', error));

        // Poblar el selector de años dinámicamente
        function populateYearSelector() {
            const years = new Set();
            energyData.forEach(padre => {
                padre['Nodos Hijo'].forEach(hijo => {
                    Object.keys(hijo).forEach(key => {
                        if (!isNaN(key) && key.length === 4 && key !== '2025') {
                            years.add(key);
                        }
                    });
                });
            });

            const sortedYears = Array.from(years).sort((a, b) => b - a);

            sortedYears.forEach(year => {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                yearSelector.appendChild(option);
            });

            // Añadir el evento para actualizar el gráfico cuando cambia el año
            yearSelector.addEventListener('change', (event) => {
                updateSankey(event.target.value);
            });
        }

        // Función para actualizar el diagrama de Sankey (Etapa 1.7: Añadir Salidas Completas)
        function updateSankey(year) {
            console.log(`Actualizando gráfico para el año: ${year}`);

            Plotly.purge(sankeyDiv);

            const produccionData = energyData.find(p => p['Nodo Padre'] === 'Producción');
            const importacionData = energyData.find(p => p['Nodo Padre'] === 'Importación');
            const variacionData = energyData.find(p => p['Nodo Padre'] === 'Variación de Inventarios');
            const exportacionData = energyData.find(p => p['Nodo Padre'] === 'Exportación');
            const ofertaInternaBrutaData = energyData.find(p => p['Nodo Padre'] === 'Oferta Interna Bruta'); // Se usa para el color del Hub
            const energiaNoAprovechadaData = energyData.find(p => p['Nodo Padre'] === 'Energía No Aprovechada');
            const consumoPropioData = energyData.find(p => p['Nodo Padre'] === 'Consumo Propio del Sector');

            if (!produccionData || !importacionData || !variacionData || !ofertaInternaBrutaData || !exportacionData || !energiaNoAprovechadaData || !consumoPropioData) {
                console.error('Faltan datos de nodos padres');
                Plotly.react(sankeyDiv, [], { title: `Datos incompletos para ${year}` });
                return;
            }

            const labels = [];
            const nodeColors = [];
            const nodeMap = new Map();
            const primaryEnergyTotals = new Map();

            const source = [];
            const target = [];
            const value = [];
            const linkColors = [];

            function addNode(name, color) {
                // Unificar el nodo 'Carbón mineral' para todos los flujos
                // Asegurar que el color sea string
                const safeColor = typeof color === 'string' ? color : '#888';
                if (name === 'Carbón mineral') {
                    if (!nodeMap.has(name)) {
                        nodeMap.set(name, labels.length);
                        labels.push(name);
                        nodeColors.push(safeColor);
                    }
                    return nodeMap.get(name);
                }
                // Para los demás nodos, comportamiento normal
                if (!nodeMap.has(name)) {
                    nodeMap.set(name, labels.length);
                    labels.push(name);
                    nodeColors.push(safeColor);
                }
                return nodeMap.get(name);
            }

            // --- 1. Definir Nodos Principales ---
            const importacionIndex = addNode(String('Importación de energéticos primarios'), importacionData.color);
            const variacionIndex = addNode(String('Variación de inventarios de Energéticos primarios'), variacionData.color);
            const produccionIndex = addNode(String('Producción'), produccionData.color);
            const primariosHubIndex = addNode(String('Oferta Interna Bruta'), ofertaInternaBrutaData.color);
            const exportacionIndex = addNode(String('Exportación'), exportacionData.color);
            const energiaNoAprovechadaIndex = addNode(String('Energía No Aprovechada'), energiaNoAprovechadaData.color);
            const consumoPropioIndex = addNode(String('Consumo Propio del Sector'), consumoPropioData.color);
            // --- 2. Procesar Flujos de Entrada (Fuentes -> Tipos de Energía) ---
            const linkSigns = [];
            const processParentNode = (nodeData, parentIndex, allowNegatives = false) => {
                // Ordenar nodos hijo por id_hijo de menor a mayor
                const hijosOrdenados = [...nodeData['Nodos Hijo']].sort((a, b) => {
                    // Si no existe id_hijo, lo ponemos al final
                    if (a.id_hijo === undefined) return 1;
                    if (b.id_hijo === undefined) return -1;
                    return a.id_hijo - b.id_hijo;
                });
                hijosOrdenados.forEach(child => {
                    const flowValue = child[year];
                    if (child.tipo === 'Energía Primaria' && flowValue !== undefined && flowValue !== 0) {
                        const childName = child['Nodo Hijo'];
                        const childColor = child.color;
                        const childIndex = addNode(childName, childColor);
                        source.push(parentIndex);
                        target.push(childIndex);
                        value.push(Math.abs(flowValue));
                        linkColors.push(
                            typeof childColor === 'string'
                                ? childColor
                                : '#888'
                        );
                        linkSigns.push(flowValue > 0 ? '+' : '-');
                        // Sumar o restar según el signo
                        if (allowNegatives && flowValue < 0) {
                            primaryEnergyTotals.set(childName, (primaryEnergyTotals.get(childName) || 0) - Math.abs(flowValue));
                        } else {
                            primaryEnergyTotals.set(childName, (primaryEnergyTotals.get(childName) || 0) + flowValue);
                        }
                    }
                });
            };
            processParentNode(importacionData, importacionIndex);
            processParentNode(variacionData, variacionIndex, true);
            processParentNode(produccionData, produccionIndex);

            // --- 3. Procesar Flujos (Tipos de Energía -> Hub "Energéticos Primarios") ---
            for (const [energyName, totalValue] of primaryEnergyTotals.entries()) {
                const energyIndex = nodeMap.get(energyName);
                const energyColor = nodeColors[energyIndex];
                source.push(energyIndex);
                target.push(primariosHubIndex);
                value.push(totalValue);
                linkColors.push(
                    typeof energyColor === 'string'
                        ? energyColor
                        : '#888'
                );
            }

            // --- 4. Procesar Flujos de Salida (Energéticos Primarios -> Exportación y Energía No aprovechada) ---
            exportacionData['Nodos Hijo'].forEach(child => {
                const flowValue = child[year];
                if (child.tipo === 'Energía Primaria' && flowValue !== undefined && flowValue !== 0) {
                    const childName = child['Nodo Hijo'];
                    const childColor = child.color;
                    const energyIndex = nodeMap.get(childName); // Obtener el índice del nodo de energético primario

                    if (energyIndex !== undefined) {
                        source.push(energyIndex);
                        target.push(exportacionIndex);
                        value.push(Math.abs(flowValue));
                        linkColors.push(
                            typeof childColor === 'string'
                                ? childColor
                                : '#888'
                        );
                    }
                }
            });
            energiaNoAprovechadaData['Nodos Hijo'].forEach(child => {
                const flowValue = child[year];
                if (child.tipo === 'Energía Primaria' && flowValue !== undefined && flowValue !== 0) {
                    const childName = child['Nodo Hijo'];
                    const childColor = child.color;
                    const energyIndex = nodeMap.get(childName); // Obtener el índice del nodo de energético primario

                    if (energyIndex !== undefined) {
                        source.push(energyIndex);
                        target.push(energiaNoAprovechadaIndex);
                        value.push(Math.abs(flowValue));
                        linkColors.push(
                            typeof childColor === 'string'
                                ? childColor
                                : '#888'
                        );
                    }
                }
            });
            // --- 5. Procesar Flujos de Salida (Oferta Interna Bruta -> Consumo Propio del Sector) ---
            consumoPropioData['Nodos Hijo'].forEach(child => {
                const flowValue = child[year];
                if (child.tipo === 'Energía Primaria' && flowValue !== undefined && flowValue !== 0) {
                    const childName = child['Nodo Hijo'];
                    const childColor = child.color;
                    const energyIndex = nodeMap.get(childName); // Obtener el índice del nodo de energético primario

                    if (energyIndex !== undefined) {
                        source.push(energyIndex);
                        target.push(consumoPropioIndex);
                        value.push(Math.abs(flowValue));
                        linkColors.push(
                            typeof childColor === 'string'
                                ? childColor
                                : '#888'
                        );
                    }
                }
            });

            // --- 6. Forzar Posiciones de los Nodos ---
            const nodeX = new Array(labels.length);
            const nodeY = new Array(labels.length);
            const ySourcePositions = {
                'Importación de energéticos primarios': 0.05,
                'Variación de inventarios de Energéticos primarios': 0.5,
                'Producción': 0.95
            };

            // Calcular sumas para el nodo de variación de inventarios
            let variacionPositiva = 0;
            let variacionNegativa = 0;
            variacionData['Nodos Hijo'].forEach(child => {
                const flowValue = child[year];
                if (child.tipo === 'Energía Primaria' && flowValue !== undefined && flowValue !== 0) {
                    if (flowValue > 0) variacionPositiva += flowValue;
                    if (flowValue < 0) variacionNegativa += flowValue;
                }
            });
            const variacionTotalAbs = Math.abs(variacionPositiva) + Math.abs(variacionNegativa);

            labels.forEach((label, i) => {
                // Asignar posición horizontal y vertical para los nodos de entrada y salida
                if (label === 'Importación de energéticos primarios') {
                    nodeX[i] = 0.01;
                    nodeY[i] = 0.05; // Arriba
                } else if (label === 'Variación de inventarios de Energéticos primarios') {
                    nodeX[i] = 0.01;
                    nodeY[i] = 0.5; // Medio
                } else if (label === 'Producción') {
                    nodeX[i] = 0.01;
                    nodeY[i] = 0.95; // Abajo
                } else if (label === 'Exportación') {
                    nodeX[i] = 0.99; // Salida derecha
                    nodeY[i] = 0.8; // Un poco más arriba que Energía No Aprovechada
                } else if (label === 'Consumo Propio del Sector') {
                    nodeX[i] = 0.99; // Salida derecha
                    nodeY[i] = 0.9; // Entre Exportación y Energía No Aprovechada
                } else if (label === 'Energía No Aprovechada') {
                    nodeX[i] = 0.99; // Salida derecha
                    nodeY[i] = 0.99; // Abajo del todo
                } else if (label === 'Energéticos Primarios') {
                    nodeX[i] = 0.5; // Mantener en el centro horizontalmente
                    nodeY[i] = 0.8; // Mover hacia abajo para que los enlaces salgan de la parte inferior
                }
            });

            // Custom hovertemplate for links with sign
            const customLinkHover = value.map((v, i) => {
                return `${labels[source[i]]} → ${labels[target[i]]}<br>Signo: ${linkSigns[i] || '+'} ${v.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} PJ<extra></extra>`;
            });

            // Usar un solo string para hovertemplate de nodos
            const customNodeHover =
                '%{label}<br>Total: %{value:,.2f} PJ' +
                '<br>%{customdata}' +
                '<extra></extra>';

            // Preparar customdata para cada nodo
            const customNodeData = labels.map(label => {
                if (label === 'Variación de inventarios de Energéticos primarios') {
                    return `+ Suma positiva: ${variacionPositiva.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} PJ<br>- Suma negativa: ${variacionNegativa.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} PJ<br>Total absoluto: ${variacionTotalAbs.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })} PJ`;
                }
                return '';
            });

            const data = {
                type: "sankey",
                orientation: "h",
                node: {
                    pad: 15,
                    thickness: 20,
                    line: { color: "black", width: 0.5 },
                    label: labels,
                    color: nodeColors,
                    hovertemplate: customNodeHover,
                    customdata: customNodeData,
                    x: nodeX,
                    y: nodeY
                },
                link: { source: source, target: target, value: value, color: linkColors, hovertemplate: customLinkHover }
            };

            const layout = { title: `Flujo de Fuentes a Oferta Interna Bruta y Salidas - ${year} (Valores en PJ)`, font: { size: 12 } };
            const config = { displaylogo: false, toImageButtonOptions: { format: 'png', filename: `sankey_energia_primaria_${year}`, setBackground: 'transparent' } };

            Plotly.newPlot(sankeyDiv, [data], layout, config);
        }
    </script>
</body>

</html>